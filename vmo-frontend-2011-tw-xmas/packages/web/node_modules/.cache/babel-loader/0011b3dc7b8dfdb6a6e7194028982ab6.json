{"ast":null,"code":"import _Promise from \"@babel/runtime-corejs2/core-js/promise\";\n// import React, { useState, useEffect, useRef, useCallback } from 'react';\n// import axios, { CancelTokenSource } from 'axios';\n// import { api } from '@vmo/web/constants/api';\n// import { LeaderboardItem as LeaderboardItemInterface } from '@vmo/share/interfaces/LeaderboardItem';\n// import { getLeaderboardVote } from '@vmo/share/services/leaderboardVote.service';\n// import { getLeaderboard } from '@vmo/share/services/leaderboard.service';\n// import { getLeaderboardCache } from '@vmo/share/services/leaderboardCache.service';\n// import { getLeaderboardEventory } from '@vmo/share/services/leaderboardEventory.service';\n// import { hashCode } from './utils';\n// type APIType = {\n//   sta: string;\n//   prod: string;\n//   isCache?: boolean;\n//   isVote?: boolean;\n//   isEventory?: boolean;\n//   firstRender?: boolean;\n// };\n// const useTypeApi = (\n//   apiList = [],\n//   method = 'GET',\n//   realTime: number,\n//   hashCheck,\n//   initialData: any,\n//   opt = {\n//     limit: 1000,\n//     cursor: '',\n//   },\n// ) => {\n//   /* eslint-disable */\n//   const timeoutKey = useRef(0);\n//   const source = useRef<CancelTokenSource>();\n//   const [loading, setLoading] = useState(false);\n//   const [polling, setPolling] = useState(false);\n//   const [leaderboardData, setLeaderboardData] = useState(initialData);\n//   const getDataRealTimeAPI = useCallback((apis = [], time, previousData) => {\n//     timeoutKey.current = setTimeout(async () => {\n//       setPolling(true);\n//       const apiArr = [];\n//       apis.forEach((item: APIType) => {\n//         if (item.isCache) {\n//           apiArr.push(\n//             getLeaderboardCache(\n//               {\n//                 sta: item.sta,\n//                 prod: item.prod,\n//               },\n//               source.current.token,\n//             ),\n//           );\n//         } else if (item.isVote) {\n//           apiArr.push(\n//             getLeaderboardVote(\n//               {\n//                 sta: item.sta,\n//                 prod: item.prod,\n//               },\n//               source.current.token,\n//             ),\n//           );\n//         } else if (item.isEventory) {\n//           apiArr.push(\n//             getLeaderboardEventory(\n//               item,\n//               source.current.token,\n//               opt.limit,\n//               opt.cursor,\n//               method,\n//             ),\n//           );\n//         } else {\n//           apiArr.push(\n//             getLeaderboard(\n//               item,\n//               source.current.token,\n//               opt.limit,\n//               opt.cursor,\n//               method,\n//             ),\n//           );\n//         }\n//       });\n//       const results = await Promise.all(apiArr);\n//       setLeaderboardData(results);\n//       setPolling(false);\n//     }, time);\n//   }, []);\n//   useEffect(() => {\n//     setLoading(true);\n//     const promiseList = [];\n//     source.current = axios.CancelToken.source();\n//     apiList.forEach((item: APIType) => {\n//       if (item.isCache) {\n//         promiseList.push(\n//           getLeaderboardCache(\n//             {\n//               sta: item.sta,\n//               prod: item.prod,\n//             },\n//             source.current.token,\n//           ),\n//         );\n//       } else if (item.isVote) {\n//         promiseList.push(\n//           getLeaderboardVote(\n//             {\n//               sta: item.sta,\n//               prod: item.prod,\n//             },\n//             source.current.token,\n//           ),\n//         );\n//       } else if (item.isEventory) {\n//         promiseList.push(\n//           getLeaderboardEventory(\n//             item,\n//             source.current.token,\n//             opt.limit,\n//             opt.cursor,\n//             method,\n//             (data: any) => {\n//               if (item.firstRender) {\n//                 setLeaderboardData([data]);\n//                 setLoading(false);\n//               }\n//             },\n//           ),\n//         );\n//       } else {\n//         promiseList.push(\n//           getLeaderboard(\n//             item,\n//             source.current.token,\n//             opt.limit,\n//             opt.cursor,\n//             method,\n//             (data: any) => {\n//               if (item.firstRender) {\n//                 setLeaderboardData([data]);\n//                 setLoading(false);\n//               }\n//             },\n//           ),\n//         );\n//       }\n//     });\n//     Promise.all(promiseList).then(async (results: any) => {\n//       setLeaderboardData(results);\n//       setLoading(false);\n//     });\n//     return () => {\n//       if (source.current) source.current.cancel();\n//       if (timeoutKey.current) clearTimeout(timeoutKey.current);\n//     };\n//   }, []);\n//   useEffect(() => {\n//     if (!polling && realTime > 0) {\n//       clearTimeout(timeoutKey.current);\n//       timeoutKey.current = 0;\n//       getDataRealTimeAPI(apiList, realTime, leaderboardData);\n//     }\n//   }, [polling, leaderboardData, apiList, realTime]);\n//   return { loading, leaderboardData };\n// };\n// export default useTypeApi;\nimport { useState, useEffect, useRef, useCallback } from 'react';\nimport axios from 'axios';\nimport { getLeaderboardVote } from '@vmo/share/services/leaderboardVote.service';\nimport { getLeaderboard } from '@vmo/share/services/leaderboard.service';\nimport { getLeaderboardCache } from '@vmo/share/services/leaderboardCache.service';\nimport { getLeaderboardEventory } from '@vmo/share/services/leaderboardEventory.service';\n\nconst useTypeApi = (apiList = [], method = 'GET', realTime, hashCheck, initialData, opt = {\n  limit: 1000,\n  cursor: ''\n}) => {\n  /* eslint-disable */\n  const timeoutKey = useRef(0);\n  const source = useRef();\n  const [loading, setLoading] = useState(false);\n  const [polling, setPolling] = useState(false);\n  const [leaderboardData, setLeaderboardData] = useState(initialData);\n  const getDataRealTimeAPI = useCallback((apis = [], time, previousData) => {\n    timeoutKey.current = setTimeout(async () => {\n      setPolling(true);\n      const apiArr = [];\n      apis.forEach(item => {\n        if (item.isCache) {\n          apiArr.push(getLeaderboardCache({\n            sta: item.sta,\n            prod: item.prod\n          }, source.current.token));\n        } else if (item.isVote) {\n          apiArr.push(getLeaderboardVote({\n            sta: item.sta,\n            prod: item.prod\n          }, source.current.token));\n        } else if (item.isEventory) {\n          apiArr.push(getLeaderboardEventory(item, source.current.token, opt.limit, opt.cursor, method));\n        } else {\n          apiArr.push(getLeaderboard(item, source.current.token, opt.limit, opt.cursor, method));\n        }\n      });\n      const results = await _Promise.all(apiArr);\n      setLeaderboardData(results);\n      setPolling(false);\n    }, time);\n  }, []);\n  useEffect(() => {\n    setLoading(true);\n    const promiseList = [];\n    source.current = axios.CancelToken.source();\n    apiList.forEach(item => {\n      if (item.isCache) {\n        promiseList.push(getLeaderboardCache({\n          sta: item.sta,\n          prod: item.prod\n        }, source.current.token));\n      } else if (item.isVote) {\n        promiseList.push(getLeaderboardVote({\n          sta: item.sta,\n          prod: item.prod\n        }, source.current.token));\n      } else if (item.isEventory) {\n        promiseList.push(getLeaderboardEventory(item, source.current.token, opt.limit, opt.cursor, method, data => {\n          if (item.firstRender) {\n            setLeaderboardData([data]);\n            setLoading(false);\n          }\n        }));\n      } else {\n        promiseList.push(getLeaderboard(item, source.current.token, opt.limit, opt.cursor, method, data => {\n          if (item.firstRender) {\n            setLeaderboardData([data]);\n            setLoading(false);\n          }\n        }));\n      }\n    });\n\n    _Promise.all(promiseList).then(async results => {\n      setLeaderboardData(results);\n      setLoading(false);\n    });\n\n    return () => {\n      if (source.current) source.current.cancel();\n      if (timeoutKey.current) clearTimeout(timeoutKey.current);\n    };\n  }, []);\n  useEffect(() => {\n    if (!polling && realTime > 0) {\n      clearTimeout(timeoutKey.current);\n      timeoutKey.current = 0;\n      getDataRealTimeAPI(apiList, realTime, leaderboardData);\n    }\n  }, [polling, leaderboardData, apiList, realTime]);\n  return {\n    loading,\n    leaderboardData\n  };\n};\n\nexport default useTypeApi;","map":{"version":3,"sources":["D:/17專案/客製化ui專案/vmo-frontend-2011-tw-xmas/packages/ui/hooks/api/useTypeApi.ts"],"names":["useState","useEffect","useRef","useCallback","axios","getLeaderboardVote","getLeaderboard","getLeaderboardCache","getLeaderboardEventory","useTypeApi","apiList","method","realTime","hashCheck","initialData","opt","limit","cursor","timeoutKey","source","loading","setLoading","polling","setPolling","leaderboardData","setLeaderboardData","getDataRealTimeAPI","apis","time","previousData","current","setTimeout","apiArr","forEach","item","isCache","push","sta","prod","token","isVote","isEventory","results","all","promiseList","CancelToken","data","firstRender","then","cancel","clearTimeout"],"mappings":";AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAGA,SAAgBA,QAAhB,EAA0BC,SAA1B,EAAqCC,MAArC,EAA6CC,WAA7C,QAAgE,OAAhE;AACA,OAAOC,KAAP,MAAyC,OAAzC;AAIA,SAASC,kBAAT,QAAmC,6CAAnC;AACA,SAASC,cAAT,QAA+B,yCAA/B;AACA,SAASC,mBAAT,QAAoC,8CAApC;AACA,SAASC,sBAAT,QAAuC,iDAAvC;;AAYA,MAAMC,UAAU,GAAG,CACjBC,OAAO,GAAG,EADO,EAEjBC,MAAM,GAAG,KAFQ,EAGjBC,QAHiB,EAIjBC,SAJiB,EAKjBC,WALiB,EAMjBC,GAAG,GAAG;AACJC,EAAAA,KAAK,EAAE,IADH;AAEJC,EAAAA,MA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","sourcesContent":["// import React, { useState, useEffect, useRef, useCallback } from 'react';\n// import axios, { CancelTokenSource } from 'axios';\n\n// import { api } from '@vmo/web/constants/api';\n// import { LeaderboardItem as LeaderboardItemInterface } from '@vmo/share/interfaces/LeaderboardItem';\n// import { getLeaderboardVote } from '@vmo/share/services/leaderboardVote.service';\n// import { getLeaderboard } from '@vmo/share/services/leaderboard.service';\n// import { getLeaderboardCache } from '@vmo/share/services/leaderboardCache.service';\n// import { getLeaderboardEventory } from '@vmo/share/services/leaderboardEventory.service';\n// import { hashCode } from './utils';\n\n// type APIType = {\n//   sta: string;\n//   prod: string;\n//   isCache?: boolean;\n//   isVote?: boolean;\n//   isEventory?: boolean;\n//   firstRender?: boolean;\n// };\n\n// const useTypeApi = (\n//   apiList = [],\n//   method = 'GET',\n//   realTime: number,\n//   hashCheck,\n//   initialData: any,\n//   opt = {\n//     limit: 1000,\n//     cursor: '',\n//   },\n// ) => {\n//   /* eslint-disable */\n//   const timeoutKey = useRef(0);\n//   const source = useRef<CancelTokenSource>();\n//   const [loading, setLoading] = useState(false);\n//   const [polling, setPolling] = useState(false);\n//   const [leaderboardData, setLeaderboardData] = useState(initialData);\n//   const getDataRealTimeAPI = useCallback((apis = [], time, previousData) => {\n//     timeoutKey.current = setTimeout(async () => {\n//       setPolling(true);\n//       const apiArr = [];\n//       apis.forEach((item: APIType) => {\n//         if (item.isCache) {\n//           apiArr.push(\n//             getLeaderboardCache(\n//               {\n//                 sta: item.sta,\n//                 prod: item.prod,\n//               },\n//               source.current.token,\n//             ),\n//           );\n//         } else if (item.isVote) {\n//           apiArr.push(\n//             getLeaderboardVote(\n//               {\n//                 sta: item.sta,\n//                 prod: item.prod,\n//               },\n//               source.current.token,\n//             ),\n//           );\n//         } else if (item.isEventory) {\n//           apiArr.push(\n//             getLeaderboardEventory(\n//               item,\n//               source.current.token,\n//               opt.limit,\n//               opt.cursor,\n//               method,\n//             ),\n//           );\n//         } else {\n//           apiArr.push(\n//             getLeaderboard(\n//               item,\n//               source.current.token,\n//               opt.limit,\n//               opt.cursor,\n//               method,\n//             ),\n//           );\n//         }\n//       });\n//       const results = await Promise.all(apiArr);\n//       setLeaderboardData(results);\n//       setPolling(false);\n//     }, time);\n//   }, []);\n//   useEffect(() => {\n//     setLoading(true);\n//     const promiseList = [];\n//     source.current = axios.CancelToken.source();\n//     apiList.forEach((item: APIType) => {\n//       if (item.isCache) {\n//         promiseList.push(\n//           getLeaderboardCache(\n//             {\n//               sta: item.sta,\n//               prod: item.prod,\n//             },\n//             source.current.token,\n//           ),\n//         );\n//       } else if (item.isVote) {\n//         promiseList.push(\n//           getLeaderboardVote(\n//             {\n//               sta: item.sta,\n//               prod: item.prod,\n//             },\n//             source.current.token,\n//           ),\n//         );\n//       } else if (item.isEventory) {\n//         promiseList.push(\n//           getLeaderboardEventory(\n//             item,\n//             source.current.token,\n//             opt.limit,\n//             opt.cursor,\n//             method,\n//             (data: any) => {\n//               if (item.firstRender) {\n//                 setLeaderboardData([data]);\n//                 setLoading(false);\n//               }\n//             },\n//           ),\n//         );\n//       } else {\n//         promiseList.push(\n//           getLeaderboard(\n//             item,\n//             source.current.token,\n//             opt.limit,\n//             opt.cursor,\n//             method,\n//             (data: any) => {\n//               if (item.firstRender) {\n//                 setLeaderboardData([data]);\n//                 setLoading(false);\n//               }\n//             },\n//           ),\n//         );\n//       }\n//     });\n//     Promise.all(promiseList).then(async (results: any) => {\n//       setLeaderboardData(results);\n//       setLoading(false);\n//     });\n//     return () => {\n//       if (source.current) source.current.cancel();\n//       if (timeoutKey.current) clearTimeout(timeoutKey.current);\n//     };\n//   }, []);\n//   useEffect(() => {\n//     if (!polling && realTime > 0) {\n//       clearTimeout(timeoutKey.current);\n//       timeoutKey.current = 0;\n//       getDataRealTimeAPI(apiList, realTime, leaderboardData);\n//     }\n//   }, [polling, leaderboardData, apiList, realTime]);\n\n//   return { loading, leaderboardData };\n// };\n\n// export default useTypeApi;\n\n\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport axios, { CancelTokenSource } from 'axios';\n\nimport { api } from '@vmo/web/constants/api';\nimport { LeaderboardItem as LeaderboardItemInterface } from '@vmo/share/interfaces/LeaderboardItem';\nimport { getLeaderboardVote } from '@vmo/share/services/leaderboardVote.service';\nimport { getLeaderboard } from '@vmo/share/services/leaderboard.service';\nimport { getLeaderboardCache } from '@vmo/share/services/leaderboardCache.service';\nimport { getLeaderboardEventory } from '@vmo/share/services/leaderboardEventory.service';\nimport { hashCode } from './utils';\n\ntype APIType = {\n  sta: string;\n  prod: string;\n  isCache?: boolean;\n  isVote?: boolean;\n  isEventory?: boolean;\n  firstRender?: boolean;\n};\n\nconst useTypeApi = (\n  apiList = [],\n  method = 'GET',\n  realTime: number,\n  hashCheck,\n  initialData: any,\n  opt = {\n    limit: 1000,\n    cursor: '',\n  },\n) => {\n  /* eslint-disable */\n  const timeoutKey = useRef(0);\n  const source = useRef<CancelTokenSource>();\n  const [loading, setLoading] = useState(false);\n  const [polling, setPolling] = useState(false);\n  const [leaderboardData, setLeaderboardData] = useState(initialData);\n  const getDataRealTimeAPI = useCallback((apis = [], time, previousData) => {\n    timeoutKey.current = setTimeout(async () => {\n      setPolling(true);\n      const apiArr = [];\n      apis.forEach((item: APIType) => {\n        if (item.isCache) {\n          apiArr.push(\n            getLeaderboardCache(\n              {\n                sta: item.sta,\n                prod: item.prod,\n              },\n              source.current.token,\n            ),\n          );\n        } else if (item.isVote) {\n          apiArr.push(\n            getLeaderboardVote(\n              {\n                sta: item.sta,\n                prod: item.prod,\n              },\n              source.current.token,\n            ),\n          );\n        } else if (item.isEventory) {\n          apiArr.push(\n            getLeaderboardEventory(\n              item,\n              source.current.token,\n              opt.limit,\n              opt.cursor,\n              method,\n            ),\n          );\n        } else {\n          apiArr.push(\n            getLeaderboard(\n              item,\n              source.current.token,\n              opt.limit,\n              opt.cursor,\n              method,\n            ),\n          );\n        }\n      });\n      const results = await Promise.all(apiArr);\n      setLeaderboardData(results);\n      setPolling(false);\n    }, time);\n  }, []);\n  useEffect(() => {\n    setLoading(true);\n    const promiseList = [];\n    source.current = axios.CancelToken.source();\n    apiList.forEach((item: APIType) => {\n      if (item.isCache) {\n        promiseList.push(\n          getLeaderboardCache(\n            {\n              sta: item.sta,\n              prod: item.prod,\n            },\n            source.current.token,\n          ),\n        );\n      } else if (item.isVote) {\n        promiseList.push(\n          getLeaderboardVote(\n            {\n              sta: item.sta,\n              prod: item.prod,\n            },\n            source.current.token,\n          ),\n        );\n      } else if (item.isEventory) {\n        promiseList.push(\n          getLeaderboardEventory(\n            item,\n            source.current.token,\n            opt.limit,\n            opt.cursor,\n            method,\n            (data: any) => {\n              if (item.firstRender) {\n                setLeaderboardData([data]);\n                setLoading(false);\n              }\n            },\n          ),\n        );\n      } else {\n        promiseList.push(\n          getLeaderboard(\n            item,\n            source.current.token,\n            opt.limit,\n            opt.cursor,\n            method,\n            (data: any) => {\n              if (item.firstRender) {\n                setLeaderboardData([data]);\n                setLoading(false);\n              }\n            },\n          ),\n        );\n      }\n    });\n    Promise.all(promiseList).then(async (results: any) => {\n      setLeaderboardData(results);\n      setLoading(false);\n    });\n    return () => {\n      if (source.current) source.current.cancel();\n      if (timeoutKey.current) clearTimeout(timeoutKey.current);\n    };\n  }, []);\n  useEffect(() => {\n    if (!polling && realTime > 0) {\n      clearTimeout(timeoutKey.current);\n      timeoutKey.current = 0;\n      getDataRealTimeAPI(apiList, realTime, leaderboardData);\n    }\n  }, [polling, leaderboardData, apiList, realTime]);\n  return { loading, leaderboardData };\n};\n\nexport default useTypeApi;"]},"metadata":{},"sourceType":"module"}